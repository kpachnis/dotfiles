#!/usr/bin/env python3
"""
Copyright (c) 2014, Konstantinos Pachnis.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

import argparse
import configparser
import errno
import getpass
import json
import os
import pathlib
import subprocess
import urllib.error
import urllib.parse
import urllib.request


def get_credentials_from_file(section):
    """Read credentials from the configuration file.

    Read the user's credentials for the specified URL from the configuration
    file.

    Arguments:
        section: URL to look for credentials.

    Returns:
        A dict mapping to user credentials. For example:

        {'username': 'john.smith',
         'password': 'jfksiqlq34323*7@32',
         'realm': 'server realm'}
    """
    config_file = '.gipo.cfg'

    try:
        config = configparser.ConfigParser()
        config.read(str(pathlib.PurePath(os.getenv('HOME')).joinpath(
            config_file)))
        return {'username': config[section]['username'],
                'password': config[section]['password'],
                'realm': config[section]['realm']}
    except KeyError:
        return None


def retrieve_manifest(url=None, auth=False, **credentials):
    """Retrieves list of repositories from manifest.

    Retrieves the repositories listed on manifest from the specfied URL.
    When the URL is not specified in the parameters, it will try and read it
    from the .gipo.json file.

    If auth is True, authenticate to the server using the the credentials
    provided from the command line or read from the config file.

    Arguments:
        url: The manifest's URL.
        auth: Enable HTTP Basic Auth.
        credentials: A dictionary with HTTP Basic Auth credentials.

    Returns:
        repositories: A dictionary with the repositories listed on manifest.
        For example:

        {'repositories': {'project1': ['git://git.example.com/p1/repo1.git',
                                       'git://git.example.com/p1/repo2.git',
                                       'git://git.example.com/p1/repo3.git']}}
    """
    url_file = '.gipo.json'

    if not url:
        try:
            with open(url_file, 'r') as f:
                url = json.loads(f.read()).get('url')
        except IOError as error:
            print("{0}. Specify the manifest URL".format(error))
            exit(error.errno)

    if not auth:
        section = urllib.parse.urlparse(url).netloc
        credentials = get_credentials_from_file(section)
        if credentials:
            auth = True

    if auth:
        auth_handler = urllib.request.HTTPBasicAuthHandler()
        auth_handler.add_password(uri=url,
                                  realm=credentials.get('realm'),
                                  user=credentials.get('username'),
                                  passwd=credentials.get('password'))
        opener = urllib.request.build_opener(auth_handler)
        urllib.request.install_opener(opener)

    try:
        manifest = urllib.request.urlopen(url)
        repositories = json.loads(manifest.read().decode('utf-8'))
    except urllib.error.HTTPError as error:
        print("{0} - {1}".format(url, error.reason))
        exit(error.errno)
    except urllib.error.URLError as error:
        print(error.reason)
        exit(error.reason.errno)
    except ValueError as error:
        print("JSON format error: {0}".format(error))
        exit(errno.EPERM)

    with open(url_file, 'w') as f:
        f.write(json.dumps({"url": url}))

    return repositories


def remote_to_local_path(url):
    """Make path relative to current directory.

    Change the remote URL path to be relative to current directory and remove
    the suffix if present.

    Arguments:
        url: The manifest's URL.

    Returns:
        path: A string represtinve the path relative to current directory.
        For example:
            'project1/repo1'
    """
    remote_path = urllib.parse.urlparse(url).path
    local_path = "/".join(pathlib.PurePath(remote_path).relative_to('/').parts[1:])
    has_suffix = pathlib.PurePath(local_path).suffix

    if has_suffix:
        return local_path.replace(pathlib.PurePath(local_path).suffix, '')
    else:
        return local_path


def git_clone(url, path):
    """Git clone.

    Clone a remote repository.

    Arguments:
        url: The repository URL.
        path: Where to clone the repository.
    """
    try:
        print("Synching {0}".format(path))
        subprocess.check_call(['git', 'clone', '-q', url, path])
    except subprocess.CalledProcessError as error:
        exit(error.returncode)
    except FileNotFoundError as error:
        print(error)
        exit(errno.ENOENT)


def git_pull(path):
    """Git pull.

    Execute git pull on the given path.

    Arguments:
        path: The git repository.
    """
    number_of_changes = git_status_number_of_changes(path)

    if not number_of_changes:
        print("Synching {0}".format(path))
        try:
            subprocess.check_call(['git', "--git-dir={0}/.git".format(path),
                                   'pull', '-q', 'origin', 'master'])
        except subprocess.CalledProcessError as error:
            exit(error.returncode)
        except FileNotFoundError as error:
            print(error)
            exit(errno.ENOENT)
    else:
        print("{0}: {1} uncommitted changes; pull manually".format(
            path, number_of_changes))
        return


def git_status(path):
    """Git status.

    Execute git status on the given path.

    Arguments:
        path: The git repository.
    """
    try:
        changes = subprocess.check_output(['git',
                                           "--git-dir={0}/.git".format(path),
                                           "--work-tree={0}".format(path),
                                           'status', '--porcelain'])
    except subprocess.CalledProcessError as error:
            exit(error.returncode)
    except FileNotFoundError as error:
            print(error)
            exit(errno.ENOENT)

    return changes.decode('utf-8')


def git_status_number_of_changes(path):
    """Count repository changes.

    Count the number of changes on a git repository.

    Arguments:
        path: Git repository path.

    Returns:
        The number of changes on repository.
    """
    return len(git_status(path).split('\n')) - 1


def repos_status(url=None, auth=False, **credentials):
    """Repositories status.

    Check the status of all repositories listed in manifest.
    If there any missing repositories inform the user to sync.

    Arguments:
        url: The manifest's URL.
        auth: Enable HTTP Basic Auth.
        credentials: A dictionary with HTTP Basic Auth credentials.
    """
    repositories_list = retrieve_manifest(url, auth, **credentials).get(
        'repositories')
    not_synched_repositories = 0
    number_of_repositories = 0

    for repositories in repositories_list.items():
        for url in repositories[1]:
            number_of_repositories += 1
            local_path = remote_to_local_path(url)

            if pathlib.Path(local_path).exists():
                has_changes = git_status_number_of_changes(local_path)
                if has_changes:
                    print("{:*^40}".format(local_path))
                    print(git_status(local_path))
            else:
                not_synched_repositories += 1

    if not_synched_repositories:
        print("{0} of {1} repositories not synched. Run sync".format(
            not_synched_repositories, number_of_repositories))


def sync_repos(url=None, auth=False, **credentials):
    """Sync repositories.

    Sync the repositories listed in the manifenst file.

    Arguments:
        url: The manifest's URL.
        auth: Enable HTTP Basic Auth.
        credentials: A dictionary with HTTP Basic Auth credentials.
    """
    repositories_list = retrieve_manifest(url, auth, **credentials).get(
        'repositories')

    for repositories in repositories_list.items():
        for url in repositories[1]:
            path = remote_to_local_path(url)
            if pathlib.Path(path).exists():
                git_pull(path)
            else:
                git_clone(url, path)


def main():
    """
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-u', '--username', help='http auth username')
    parser.add_argument('-p', '--password', help='http auth password')
    parser.add_argument('-r', '--realm', help='http auth realm')
    parser.add_argument('url', metavar='URL', nargs='?', default=None,
                        help='manifest URL')

    actions = parser.add_mutually_exclusive_group()
    actions.add_argument('-S', '--sync', action='store_true',
                         help='synchronize repositories')
    actions.add_argument('-s', '--status', action='store_true',
                         help='repositories status')

    args = parser.parse_args()

    try:
        if args.username and args.sync:
            if not args.password:
                args.password = getpass.getpass()

            sync_repos(args.url, auth=True, username=args.username,
                       password=args.password, realm=args.realm)
        elif args.sync:
            sync_repos(args.url)
        elif args.username and args.status:
            if not args.password:
                args.password = getpass.getpass()

            repos_status(args.url, auth=True, username=args.username,
                         password=args.password, realm=args.realm)
        elif args.status:
            repos_status(args.url)
        else:
            parser.print_help()
    except KeyboardInterrupt:
        exit()

if __name__ == '__main__':
    main()
